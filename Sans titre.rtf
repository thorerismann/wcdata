{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 start_value = 100\
\
def first_func(x):\
    return 1/math.sqrt(x)\
def second_func(x):\
    return 2*x\
\
an_array=[]\
\
def make_a_2column_array(start_value, func_one=first_func, func_two=second_func, holder=an_array, reps=10):\
    """A method to build an array using a recursive\
    """\
    \
    # if there are less results than reps\
    # calculate another set\
    if len(holder) < reps:        \
        # if this is the first value\
        # use the start value\
        if len(holder) == 0:\
            # the decay value\
            a=func_one(start_value)            \
            # b is a func of a\
            b=func_two(a)\
        else:\
            # use the last generated            \
            a= func_one(holder[-1][1])\
            # b is still a function of a\
            b= func_two(a)\
        \
        # append this new set of values\
        holder.append((a,b))\
        \
        # call the function again\
        return make_a_2column_array(start_value, func_one=func_one, func_two=func_two, holder=holder, reps=reps)\
    \
    # if results = reps then return the holder\
    else:\
        return holder\
    \
        \
    \
make_a_2column_array(start_value, func_one=first_func, func_two=second_func, holder=an_array, reps=10)   }